 矩阵相关
   1 矩阵是 x，y ，z 三个坐标轴

 y ｜
   ｜   z
   ｜————————————>  x
   z轴 是横穿 平面 （x，y）坐标系  opengl旋转 是按照某一个轴 旋转
   对应的计算 在 课件资料有
   旋转时 如果是 左右 图像旋转 一定是 z 轴旋转 因为 z 是横穿平面的所以
   想象一个 图片 有一个针 穿过 所以你转这个针   图片是左右旋转的

   如果沿着 x旋转 图片是前后翻转的 。


   整体流程

   1surface 生命周期 回调 jni 的OpengL
   2 Opengl.cpp 中
    onsurfaceCreate   创建egl 线程 初始化egl 环境 设置 egl 中 回调方法 create  change draw    在
    opengl.cpp 中定义回调方法  ，回调方法中 调用 对应render 的几个方法   。也就是FilterOne
    filterOne 中 在对应方法 中进行 opengl 的 shader 加载 等等

    onsurfaceChange   传给 egl 线程和 render

    -----------------------------------------------------------
    FFMpeg 笔记
    pts dts time_base  博客
    https://www.cnblogs.com/ZY-Dream/p/10245464.html
    得出的结论为 pts 是告诉什么时间显示这帧 数据 但是pts 单位并不是多少秒。
    我们视频会把自己分成很多刻度 类似于一个尺子 每一个视频帧都对应自己的刻度 。然而计算这一帧是第几秒
    就需要time_base  time_base 是每个刻度多少秒。 比如一个视频是25 帧 那么 每一帧就是1/25 秒
    那么我们计算 某一帧 是第几秒 就需要pts *time_base;

    yuv 420 p 是视频裸数据  不是我们普通意义上的mp4 等等 视频格式 h264 h265 是一种压缩算法 mp4 是一种视频的封装格式
    ------------------------------------------------------------
    # C/C++ 笔记#

   （1）指针:
    一个字节 = 8 bit  （1 byte = 8 bit ）8bit 01 01 01 01
    int i = 100;
    int* p = &i;

    int y = 200;
    int* p1 = &y;

    p=p1; //这里把 p1 赋值给 p  并不是把 y的地址赋值给了 i 因为 p 是一个指针变量
    它一开始是 i的地址的值。。 这里交换以后 p就变成了y的地址的值。而i的地址从来都没有变过

    *p = *p1; //这里赋值其实就没有意义了。因为 *p已经指向了 y的值也就是200

   （2）二级指针:
    int** p2 = &p;    //p2代表  p的地址的值  ,  *p2 表示 p的地址存储的东西 也就是i 的地址的值

    *P 代表 从某个地址取 它存储的东西。

   （3）静态内存与动态内存:
    栈内存 ： 静态内存开辟 方法结束 自动回收 ,例如 int arr[1024]
    堆内存 ： 动态内存开辟 需要手动回收  例如malloc  释放 free
    注意的点

    realloc 是对已经malloc 的扩展增加申请，
    如果内存不足就会返回NULL
    如果内存足够  当前malloc 返回的内存地址 如果可以进行扩展那么 返回的就是原来的指针
    否则 会 找一块别的内存区域 将原来的复制过来 再扩展  这时 返回的指针 已经不是原来的指针了

    (4)数组 ：
    数组的首个元素的地址就是整个数组的地址
    int arr[] ={1,3,4};
    arr 即为数组的地址  可以用 指针 表示 int* arr_p=arr;
    也可以写成 int* arr_p = &arr[0] (第零个元素的地址)

    (5)字符串的定义:
    char str[]={'a','b','c','\0'}; //这种形式声明字符串 必须以\0 结尾 才知道字符串结束
    char *c_str="abc";
    其实第二种就是 用char * 指代一个char 数组 与 int 数组类似 但是第二种无法修改元素
    想操作字符串进行拼接 拷贝等， 必须使用 char  数组形式进行 。

    (6)结构体字节计算规则:
    struct Woker{
     int age 4
     double  8
     char name[10]  （char 一个字节） 10
    }
    1 按照最大字节计算 如上 age 4 字节 double 8 字节
    age 按照 8 字节补齐
    2 算的时候按照 基本数据类型计算
    3 首先会把所有的字节数加起来 是否能够整除 最大属性（基本数据类型）的字节数 ，如果
    不够会往上累加 直到能整除为止
    4


