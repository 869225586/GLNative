 矩阵相关
   1 矩阵是 x，y ，z 三个坐标轴

 y ｜
   ｜   z
   ｜————————————>  x
   z轴 是横穿 平面 （x，y）坐标系  opengl旋转 是按照某一个轴 旋转
   对应的计算 在 课件资料有
   旋转时 如果是 左右 图像旋转 一定是 z 轴旋转 因为 z 是横穿平面的所以
   想象一个 图片 有一个针 穿过 所以你转这个针   图片是左右旋转的

   如果沿着 x旋转 图片是前后翻转的 。


   整体流程

   1surface 生命周期 回调 jni 的OpengL
   2 Opengl.cpp 中
    onsurfaceCreate   创建egl 线程 初始化egl 环境 设置 egl 中 回调方法 create  change draw    在
    opengl.cpp 中定义回调方法  ，回调方法中 调用 对应render 的几个方法   。也就是FilterOne
    filterOne 中 在对应方法 中进行 opengl 的 shader 加载 等等

    onsurfaceChange   传给 egl 线程和 render

    -----------------------------------------------------------
    FFMpeg 笔记
    pts dts time_base  博客
    https://www.cnblogs.com/ZY-Dream/p/10245464.html
    得出的结论为 pts 是告诉什么时间显示这帧 数据 但是pts 单位并不是多少秒。
    我们视频会把自己分成很多刻度 类似于一个尺子 每一个视频帧都对应自己的刻度 。然而计算这一帧是第几秒
    就需要time_base  time_base 是每个刻度多少秒。 比如一个视频是25 帧 那么 每一帧就是1/25 秒
    那么我们计算 某一帧 是第几秒 就需要pts *time_base;

    yuv 420 p 是视频裸数据  不是我们普通意义上的mp4 等等 视频格式 h264 h265 是一种压缩算法 mp4 是一种视频的封装格式
    ------------------------------------------------------------
    # C++ 笔记#
    一个字节 = 8 bit  （1 byte = 8 bit ）8bit 01 01 01 01
    int i = 100;
    int* p = &i;

    int y = 200;
    int* p1 = &y;

    p=p1; //这里把 p1 赋值给 p  并不是把 y的地址赋值给了 i 因为 p 是一个指针变量
    它一开始是 i的地址的值。。 这里交换以后 p就变成了y的地址的值。而i的地址从来都没有变过

    *p = *p1; //这里赋值其实就没有意义了。因为 *p已经指向了 y的值也就是200
