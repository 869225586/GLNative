  # C/C++ 笔记#

   （1）指针:
    一个字节 = 8 bit  （1 byte = 8 bit ）8bit 01 01 01 01
    int i = 100;
    int* p = &i;

    int y = 200;
    int* p1 = &y;

    p=p1; //这里把 p1 赋值给 p  并不是把 y的地址赋值给了 i 因为 p 是一个指针变量
    它一开始是 i的地址的值。。 这里交换以后 p就变成了y的地址的值。而i的地址从来都没有变过

    *p = *p1; //这里赋值其实就没有意义了。因为 *p已经指向了 y的值也就是200

   （2）二级指针:
    int** p2 = &p;    //p2代表  p的地址的值  ,  *p2 表示 p的地址存储的东西 也就是i 的地址的值

    *P 代表 从某个地址取 它存储的东西。

   （3）静态内存与动态内存:
    栈内存 ： 静态内存开辟 方法结束 自动回收 ,例如 int arr[1024]
    堆内存 ： 动态内存开辟 需要手动回收  例如malloc  释放 free
    注意的点

    realloc 是对已经malloc 的扩展增加申请，
    如果内存不足就会返回NULL
    如果内存足够  当前malloc 返回的内存地址 如果可以进行扩展那么 返回的就是原来的指针
    否则 会 找一块别的内存区域 将原来的复制过来 再扩展  这时 返回的指针 已经不是原来的指针了

    (4)数组 ：
    数组的首个元素的地址就是整个数组的地址
    int arr[] ={1,3,4};
    arr 即为数组的地址  可以用 指针 表示 int* arr_p=arr;
    也可以写成 int* arr_p = &arr[0] (第零个元素的地址)

    (5)字符串的定义:
    char str[]={'a','b','c','\0'}; //这种形式声明字符串 必须以\0 结尾 才知道字符串结束
    char *c_str="abc";
    其实第二种就是 用char * 指代一个char 数组 与 int 数组类似 但是第二种无法修改元素
    想操作字符串进行拼接 拷贝等， 必须使用 char  数组形式进行 。

    (6)结构体字节计算规则:
    struct Woker{
     int age 4
     double  8
     char name[10]  （char 一个字节） 10
    }
    1 按照最大字节计算 如上 age 4 字节 double 8 字节
    age 按照 8 字节补齐
    2 算的时候按照 基本数据类型计算
    3 首先会把所有的字节数加起来 是否能够整除 最大属性（基本数据类型）的字节数 ，如果
    不够会往上累加 直到能整除为止
    4



